from typing import List


class CNF:
    """
    Represents a CNF statement
    """

    # Symbols used to print out the expression:
    AND_SYMBOL = "∧"
    OR_SYMBOL = "∨"
    NEG_SYMBOL = "¬"
    EMPTY_CLAUSE_SYMBOL = "□"
    OPEN_PARENTHESIS = "("
    CLOSE_PARENTHESIS = ")"

    def __init__(self, clauses: List[List[int]], variable_count: int):
        self.clauses = clauses
        self.variable_count = variable_count

    def _literal_to_str(self, literal: int) -> str:
        return f"p{literal}" if literal > 0 else f"{self.NEG_SYMBOL}p{abs(literal)}"

    def _clause_to_str(self, clause: List[int]) -> str:
        if len(clause) == 0:
            return f"{self.OPEN_PARENTHESIS}{self.EMPTY_CLAUSE_SYMBOL}{self.CLOSE_PARENTHESIS}"
        ORed_literals = f" {self.OR_SYMBOL} ".join(map(self._literal_to_str, clause))
        return self.OPEN_PARENTHESIS + ORed_literals + self.CLOSE_PARENTHESIS

    def _to_string(self) -> str:
        return f" {self.AND_SYMBOL} ".join(map(self._clause_to_str, self.clauses))

    def __str__(self) -> str:
        return self._to_string()

    def __repr__(self) -> str:
        return self._to_string()

class VariableTranslator:
    """
    A helper class that allows to translate "our variables" from the language defined by us to normalized variables used by
    a DIMACS CNF SAT solver such as Glucose.
    """
    def __init__(self):
        self.next_normalized_var_number = 1
        self.normalized_to_our_vars = {}
        self.our_to_normalized_vars = {}

    def get_normalized_var(self, our_var: int) -> int:
        """ Returns the normalized variable for our given variable """
        glucose_var_translation = self.our_to_normalized_vars.get(our_var, None)
        if glucose_var_translation is None:
            glucose_var_translation = self.next_normalized_var_number
            self.normalized_to_our_vars[glucose_var_translation] = our_var
            self.our_to_normalized_vars[our_var] = glucose_var_translation
            self.next_normalized_var_number += 1
        return glucose_var_translation

    def get_our_var(self, normalized_var: int) -> int:
        """ Returns the our_var for given normalized variable """
        return self.normalized_to_our_vars.get(normalized_var)

    def get_var_count(self) -> int:
        """ Returns the number of distinct variables used """
        return self.next_normalized_var_number - 1

class DIMACS_CNF(CNF):
    """
    Represents a CNF statement in DIMACS format: https://jix.github.io/varisat/manual/0.2.0/formats/dimacs.html
    """

    DIMACS_HEADER_COMMENT = "Generated by exact_cover_sat, made by Samuel Bartík" # Set to None to optionally disable

    def __init__(self, clauses: List[List[int]], variable_count: int):
        super().__init__(clauses, variable_count)

    def save_to_file(self, filepath: str) -> None:
        """
        Saves the CNF to a specified file

        :exception Exception: If an error occurs while saving the CNF to a file
        """
        try:
            with open(filepath, 'w') as f:
                if self.DIMACS_HEADER_COMMENT is not None: f.write(f"c {self.DIMACS_HEADER_COMMENT}\n") # Optionally add a comment
                # First, output a header
                f.write(f"p cnf {self.variable_count} {len(self.clauses)}\n")
                # Then individual clauses
                for clause in self.clauses:
                    f.write(f"{' '.join(map(str, clause))} 0\n")
        except Exception as e:
            raise Exception(f"Failed to save CNF to {filepath}: {e}")

    def convert_back_to_denormalized_cnf(self, translator: VariableTranslator) -> CNF:
        """
        Converts a normalized CNF formula into a CNF formula based on the provided variable translator converting from normalized variables to our definition of variables.
        :param translator: Translator used to translate variables back to our definition of variables
        :return: Denormalized CNF formula
        """
        translated_clauses = []

        for normalized_clause in self.clauses:
            translated_clauses.append(list(map(translator.get_normalized_var, normalized_clause)))

        return CNF(translated_clauses, self.variable_count)